
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6 on Sun May 25 23:31:23 2008

# Copyright 2008 Martin Manns
# Distributed under the terms of the GNU General Public License
# generated by wxGlade 0.6 on Mon Mar 17 23:22:49 2008

# --------------------------------------------------------------------
# pyspread is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyspread is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyspread.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------

import wx

"""
_grid_cell_actions.py
=======================

Module for cell level main grid level actions.

Provides:
---------
  1. CellActions: Changes to cell code
  
"""

class CellActions(object):
    """Mixin class that supplies Cell code additions, changes and deletion"""
        
    def set_cell_code_fast(self,  key,  code):
        """Sets code for key cell"""
        
        self.code_array.__setitem__(key, code, fast=True)
        
    def delete_cell(self,  key):
        """Deletes key cell"""
        
        try:
            self.code_array.pop(key)
        except KeyError:
            pass
    
    def _set_cell_attr(self, selection, table, attr):
        """Sets cell attr for key cell
        
        Parameters
        ----------
        
        attr: dict
        \tContains cell attribute keys
        \tkeys in ["borderwidth_bottom", "borderwidth_right", 
        \t"bordercolor_bottom", "bordercolor_right", 
        \t"bgcolor", "textfont",
        \t"pointsize", "fontweight", "fontstyle", "textcolor", "underline",
        \t"strikethrough", "angle", "column-width", "row-height", 
        \t"vertical_align", "justification", "frozen"]
        
        """
        
        if selection is not None:
            self.code_array.cell_attributes.append((selection, table, attr))    
    
    def set_attr(self, attr, value, selection=None):
        """Sets attr of current selection to value"""
        
        if selection is None:
            selection = self.grid.selection
        
        if not selection:
            # Add current cell to selection so that it gets changed
            selection.cells.append(self.cursor[:2])
        
        attrs = {attr: value}
        
        table = self.grid.current_table
        
        # Change model
        
        self.grid.actions._set_cell_attr(selection, table, attrs)
    
    def set_border_attr(self, attr, value, borders):
        """Sets border attribute by adjusting selection to borders"""
        
        selection = self.grid.selection
        
        if "top" in borders:
            adj_selection = selection + (-1, 0)
            self.set_attr(attr + "_bottom", value, adj_selection)
        
        if "bottom" in borders:
            self.set_attr(attr + "_bottom", value)
            
        if "left" in borders:
            adj_selection = selection + (0, -1)
            self.set_attr(attr + "_right", value, adj_selection)
        
        if "right" in borders:
            self.set_attr(attr + "_right", value)
    
    def toggle_attr(self, attr):
        """Toggles an attribute attr for current selection"""
        
        selection = self.grid.selection
        
        # Selection or single cell access?
        
        if selection:
            value = self.get_new_selection_attr_state(selection, attr)
            
        else:
            value = self.get_new_cell_attr_state(self.cursor, attr)
        
        # Special handling for frozen cells 
        
        if attr == "frozen" and not value:
            for key_repr in self.grid.code_array.frozen_keys.keys():
                if (selection and eval(key_repr)[:2] in selection) or \
                   eval(key_repr) == self.cursor:
                    self.grid.code_array.frozen_keys.pop(key_repr)
        
        # Set the toggled value
        
        self.set_attr(attr, value)
    
    # Only cell attributes that can be toogled are contained
    
    attr_toggle_values = { \
        "fontweight": [wx.NORMAL, wx.BOLD],
        "fontstyle": [wx.NORMAL, wx.ITALIC],
        "underline": [True, False],
        "strikethrough": [True, False],
        "vertical_align": ["top", "middle", "bottom"],
        "justification": ["left", "center", "right"],
        "frozen": [True, False],
        }
    
    def get_new_cell_attr_state(self, key, attr_key):
        """Returns new attr cell state for toggles
        
        Parameters
        ----------
        key: 3-Tuple
        \tCell for which attr toggle shall be returned
        attr_key: Hashable
        \tAttribute key
        
        """
        
        cell_attributes = self.grid.code_array.cell_attributes
        attr_values = self.attr_toggle_values[attr_key]
        
        # Map attr_value to next attr_value
        attr_map = dict(zip(attr_values, attr_values[1:] + attr_values[:1]))
        
        # Return next value from attr_toggle_values value list
        
        return attr_map[cell_attributes[key][attr_key]]
    
    def get_new_selection_attr_state(self, selection, attr_key):
        """Returns new attr selection state for toggles
        
        Parameters
        ----------
        selection: Selection object
        \tSeelction for which attr toggle shall be returned
        attr_key: Hashable
        \tAttribute key
        
        """
        
        cell_attributes = self.grid.code_array.cell_attributes
        attr_values = self.attr_toggle_values[attr_key]
        
        # Map attr_value to next attr_value
        attr_map = dict(zip(attr_values, attr_values[1:] + attr_values[:1]))
        
        selection_attrs = \
            (attr for attr in cell_attributes if attr[0] == selection)
                    
        attrs = {}
        for selection_attr in selection_attrs:
            attrs.update(selection_attr[2])
            
        if attr_key in attrs:
            return attr_map[attrs[attr_key]]
            
        else:
            # Default next value
            return self.attr_toggle_values[attr_key][1]
