#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2008 Martin Manns
# Distributed under the terms of the GNU General Public License
# generated by wxGlade 0.6 on Mon Mar 17 23:22:49 2008

# --------------------------------------------------------------------
# pyspread is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# pyspread is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with pyspread.  If not, see <http://www.gnu.org/licenses/>.
# --------------------------------------------------------------------

"""
_grid_renderer
==============

Provides
--------

1) TextRenderer: Draws the grid
2) Background: Background drawing

"""

import types

import wx.grid

import lib.xrect as xrect

from lib._interfaces import get_brush_from_data, get_pen_from_data, \
                            get_font_from_data, hex_to_rgb

from config import odftags, selected_cell_brush

class GridRenderer(wx.grid.PyGridCellRenderer):
    """This renderer draws borders and text at specified font, size, color"""

    def __init__(self, table):
        
        wx.grid.PyGridCellRenderer.__init__(self)
        
        self.table = table
        
        # Background key is (width, height, bgbrush, 
        # borderpen_bottom, borderpen_right)
        self.backgrounds = {} 
        
        # Zoom of grid
        self.zoom = 1.0
    
    def get_textbox_edges(self, text_pos, text_extent):
        """Returns upper left, lower left, lower right, upper right of text"""
        
        string_x, string_y, angle = text_pos
        
        pt_ul =  string_x, string_y 
        pt_ll =  string_x, string_y + text_extent[1]
        pt_lr =  string_x + text_extent[0], string_y + text_extent[1]
        pt_ur =  string_x + text_extent[0], string_y
        
        if not -0.0001 < angle < 0.0001:
            rot_angle = angle / 180.0 * pi
            def rotation(x, y, angle, base_x=0.0, base_y=0.0):
                x -= base_x
                y -= base_y

                __x =  cos(rot_angle) * x + sin(rot_angle) * y
                __y = -sin(rot_angle) * x + cos(rot_angle) * y

                __x += base_x
                __y += base_y

                return __x, __y
            
            pt_ul = rotation(pt_ul[0], pt_ul[1], rot_angle, 
                              base_x=string_x, base_y=string_y)
            pt_ll = rotation(pt_ll[0], pt_ll[1], rot_angle, 
                              base_x=string_x, base_y=string_y)
            pt_ur = rotation(pt_ur[0], pt_ur[1], rot_angle, 
                              base_x=string_x, base_y=string_y)
            pt_lr = rotation(pt_lr[0], pt_lr[1], rot_angle, 
                              base_x=string_x, base_y=string_y)
        
        return pt_ul, pt_ll, pt_lr, pt_ur
    
    def get_text_rotorect(self, text_pos, text_extent):
        """Returns a RotoRect for given cell text"""
        
        import lib.xrect as xrect
        
        pt_ll = self.get_textbox_edges(text_pos, text_extent)[1]
        
        rr_x, rr_y = pt_ll
        
        angle = float(text_pos[2]) 
        
        return xrect.RotoRect(rr_x, rr_y, text_extent[0], text_extent[1], angle)
    
    def draw_blocking_rect(self, dc, cell_rect, block_direction):
        """Draws block rectangles for given direction and blocking cell
        
        Properties
        ----------
        dc: wx.DC
        \t Target draw context
        block_direction: String in overflow_rects.keys()
        \tIdentifier for direction, in which blocking rect shall point
        cell_rect: wx.Rect
        \tRect of blocking cell
        
        """

        arrow, trafo = overflow_rects[block_direction]

        arrow_x, arrow_y = trafo(cell_rect.x, cell_rect.y,
                          cell_rect.width, cell_rect.height)

        dc.DrawBitmap(arrow, arrow_x, arrow_y, True)
    
    def draw_textbox(self, dc, text_pos, text_extent):
    
        pt_ul, pt_ll, pt_lr, pt_ur = self.get_textbox_edges(text_pos, 
                                                            text_extent)
        
        dc.DrawLine(pt_ul[0], pt_ul[1], pt_ll[0], pt_ll[1])
        dc.DrawLine(pt_ll[0], pt_ll[1], pt_lr[0], pt_lr[1])
        dc.DrawLine(pt_lr[0], pt_lr[1], pt_ur[0], pt_ur[1])
        dc.DrawLine(pt_ur[0], pt_ur[1], pt_ul[0], pt_ul[1])

    def _get_full_cells(self, dc, grid, key, text_pos, text_extent):
        """Generator of full cells from key in direction
        
        Parameters
        ----------
        key: 3-tuple of Integer
        \tCurrent cell
        text_pos: 3-tuple
        \tPosition and direction of text

        """
        
        row, col, tab = key
        
        blocking_distance = None
        
        textbox = self.get_text_rotorect(text_pos, text_extent)
        
        for distance, __row, __col in grid.colliding_cells(row, col, textbox):
            # Draw blocking arrows if locking cell is not empty
            
            if not( \
               (blocking_distance is None or distance == blocking_distance) \
               and not self.table[__row, __col, tab]):
               
                yield __row, __col, tab

    def _get_empty_cells(self, dc, grid, key, text_pos, text_extent):
        """Generator of empty cells from key in direction
        
        Parameters
        ----------
        key: 3-tuple of Integer
        \tCurrent cell
        text_pos: 3-tuple
        \tPosition and direction of text

        """
        
        row, col, tab = key
        
        blocking_distance = None
        
        textbox = self.get_text_rotorect(text_pos, text_extent)
        
        for distance, __row, __col in grid.colliding_cells(row, col, textbox):
            
            if blocking_distance is None or distance == blocking_distance:
                if self.table[__row, __col, tab]:
                    blocking_distance = distance
                else:
                    yield __row, __col, tab
    
    def _get_available_space_rects(self, dc, grid, key, rect, text_pos, 
                      text_extent, res_text):
        """Returns rects needed by key cell that are in available space"""
        
        yield rect
        
        for cell in self._get_empty_cells(dc, grid, key, text_pos, text_extent):
            __row, __col, _ = cell
            cell_rect = grid.CellToRect(__row, __col)
            
            yield cell_rect

    def draw_text_label(self, dc, res, rect, grid, pysgrid, key):
        """Draws text label of cell"""
        
        res_text = unicode(res)
        
        if not res_text:
            return
        
        row, col, tab = key
        
        textattributes = pysgrid.get_sgrid_attr(key, "textattributes")
        
        textfont = get_font_from_data( \
            pysgrid.get_sgrid_attr(key, "textfont"))
        
        self.set_font(dc, textfont, textattributes, self.zoom)
        
        text_pos = self.get_text_position(dc, rect, res_text, 
                                          textattributes)
        
        __rect = xrect.Rect(rect.x, rect.y, rect.width, rect.height)
        
        text_extent = dc.GetTextExtent(res_text)
        
        # If cell rect stays inside cell, we simply draw
        
        if all(__rect.is_point_in_rect(*textedge) \
          for textedge in self.get_textbox_edges(text_pos, text_extent)):
            clipping = False
        else:
            clipping = True
            clip_rects = self._get_available_space_rects(dc, grid, key, rect, 
                                text_pos, text_extent, res_text)
        
        if clipping:
            for clip_rect in clip_rects:
                dc.SetClippingRect(clip_rect)
                dc.DrawRotatedText(res_text, *text_pos)
                text_extent = dc.GetTextExtent(res_text)
                self._draw_strikethrough_line(grid, dc, rect, text_pos, 
                        text_extent, textattributes)
                dc.DestroyClippingRegion()
        else:
            dc.DrawRotatedText(res_text, *text_pos)
            text_extent = dc.GetTextExtent(res_text)
            self._draw_strikethrough_line(grid, dc, rect, text_pos, 
                        text_extent, textattributes)
        
        
    def _draw_strikethrough_line(self, grid, dc, rect, 
                                 text_pos, text_extent, textattributes):
        """Draws a strikethrough line if needed"""
        
        try:
            strikethrough_tag = odftags["strikethrough"]
            strikethrough = textattributes[strikethrough_tag]
            if strikethrough == "transparent":
                return
        except KeyError:
            return
            
        string_x, string_y, angle = text_pos
        
        strikethroughwidth = max(1, int(round(1.5 * self.zoom)))
        dc.SetPen(wx.Pen(wx.BLACK, strikethroughwidth, wx.SOLID))

        x1 = string_x
        y1 = string_y + text_extent[1] / 2
        x2 = string_x + text_extent[0]
        y2 = string_y + text_extent[1] / 2

        if not -0.0001 < angle < 0.0001:

            rot_angle = angle / 180.0 * pi

            def rotation(x, y, angle, base_x=0.0, base_y=0.0):
                x -= base_x
                y -= base_y

                __x =  cos(rot_angle) * x + sin(rot_angle) * y
                __y = -sin(rot_angle) * x + cos(rot_angle) * y

                __x += base_x
                __y += base_y

                return __x, __y

            x1, y1 = rotation(x1, y1, rot_angle, 
                              base_x=string_x, base_y=string_y)
            x2, y2 = rotation(x2, y2, rot_angle,
                              base_x=string_x, base_y=string_y)

        dc.DrawLine(x1, y1, x2, y2)

    def set_font(self, dc, textfont, textattributes, zoom):
        """Sets font, text color and style"""
        try:
            fontcolortag = odftags["fontcolor"]
            textcolor = textattributes[fontcolortag]
        except KeyError:
            textcolor = wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOWTEXT)
        
        try:
            underline_mode = textattributes[odftags["underline"]]
        except KeyError:
            underline_mode = None
        
        dc.SetBackgroundMode(wx.TRANSPARENT)
        dc.SetTextForeground(textcolor)
        
        # Adjust font size to zoom
        
        font_size = textfont.GetPointSize()
        
        zoomed_fontsize = max(1, int(round(font_size * zoom)))
        
        zoomed_font = wx.Font(zoomed_fontsize, textfont.GetFamily(),
            textfont.GetStyle(), textfont.GetWeight(), 
            underline_mode == "continuous", textfont.GetFaceName())
        dc.SetFont(zoomed_font)
    
    def get_text_position(self, dc, rect, res_text, textattributes):
        """Returns text x, y, angle position in cell"""
        
        text_extent = dc.GetTextExtent(res_text)
        
        try: 
            text_align_tag = odftags["textalign"]
            horizontal_align = textattributes[text_align_tag]
        except KeyError: 
            pass
        
        try:
            vert_align_tag = odftags["verticalalign"]
            vertical_align = textattributes[vert_align_tag]
        except KeyError:
            vertical_align = "top"
        
        if vertical_align == "middle":
            string_y = rect.y + rect.height / 2 - text_extent[1] / 2 + 1
            
        elif vertical_align == "bottom":
            string_y = rect.y + rect.height - text_extent[1]
        
        else:
            string_y = rect.y + 2
        
        try:
            rot_angle_tag = odftags["rotationangle"]
            angle = float(textattributes[rot_angle_tag])
        except KeyError:
            angle = 0.0
        
        try:
            justification_tag = odftags["justification"]
            justification = textattributes[justification_tag]
        except KeyError:
            justification = "left"
        
        if justification == "left":
            string_x = rect.x + 2
            
        elif justification == "center":
            # First calculate x value for unrotated text
            string_x = rect.x + rect.width / 2 - 1
            
            # Now map onto rotated xy position
            rot_angle = angle / 180.0 * pi
            string_x = string_x - text_extent[0] / 2 * cos(rot_angle)
            string_y = string_y + text_extent[0] / 2 * sin(rot_angle)

        elif justification == "right":
            # First calculate x value for unrotated text
            string_x = rect.x + rect.width - 2
            
            # Now map onto rotated xy position
            rot_angle = angle / 180.0 * pi
            string_x = string_x - text_extent[0] * cos(rot_angle)
            string_y = string_y + text_extent[0] * sin(rot_angle)
        else:
            raise ValueError, "Cell justification must be left, center or right"
    
        return string_x, string_y, angle
        
    def Draw(self, grid, attr, dc, rect, row, col, isSelected, printing=False):
        """Draws the cell border and content"""
        
        pysgrid = self.table.data_array
        key = (row, col, grid.current_table)
        
        if isSelected:
            grid.selection_present = True
            
            bg = Background(grid, row, col, self.table.current_table,
                            isSelected)
        else:
            _, _, width, height = grid.CellToRect(row, col)
            
            bg_components = ["bgbrush", "borderpen_bottom", "borderpen_right"]
            
            bg_key = tuple([width, height] + \
                [tuple(self.table.data_array.get_sgrid_attr(key, bgc)) \
                                for bgc in bg_components])
            
            try:
                bg = self.backgrounds[bg_key]
                
            except KeyError:
                if len(self.backgrounds) > 10000:
                    # self.backgrounds may grow quickly
                    
                    self.backgrounds = {}
                
                bg = self.backgrounds[bg_key] = Background(grid, *key)
            
        if wx.Platform == "__WXGTK__" and not printing:
            mask_type = wx.AND
        else:
            mask_type = wx.COPY
            
        dc.Blit(rect.x, rect.y, rect.width, rect.height,
                bg.dc, 0, 0, mask_type)
        
        
        # Check if the dc is drawn manually be a return func
        
        res = self.table[row, col, grid.current_table]
        
        if type(res) is types.FunctionType:
            # Add func_dict attribute 
            # so that we are sure that it uses a dc
            try:
                res(grid, attr, dc, rect)
            except TypeError:
                pass
        
        elif res is not None:
            self.draw_text_label(dc, res, rect, grid, pysgrid, key)
        
# end of class TextRenderer


class Background(object):
    """Memory DC with background content for given cell"""
    
    def __init__(self, grid, row, col, tab, selection=False):
        self.grid = grid
        self.table = grid.grid_table
        self.key = row, col, tab
        
        self.dc = wx.MemoryDC() 
        self.rect = grid.CellToRect(row, col)
        self.bmp = wx.EmptyBitmap(self.rect.width,self.rect.height)
        
        self.selection = selection
        
        self.dc.SelectObject(self.bmp)
        self.dc.SetBackgroundMode(wx.TRANSPARENT)

        self.dc.SetDeviceOrigin(0,0)
        
        self.draw()
        
    def draw(self):
        """Does the actual background drawing"""
        
        self.draw_background(self.dc)
        self.draw_border_lines(self.dc)

    def draw_background(self, dc):
        """Draws the background of the background"""
        
        if self.selection:
            bgbrush = wx.Brush(selected_cell_brush)
        else:
            bgbrush = get_brush_from_data( \
                self.table.data_array.get_sgrid_attr(self.key, "bgbrush"))
        
        dc.SetBrush(bgbrush)
        dc.SetPen(wx.TRANSPARENT_PEN)
        dc.DrawRectangle(0, 0, self.rect.width, self.rect.height)

    def draw_border_lines(self, dc):
        """Draws lines"""
        
        x, y, w, h  = 0, 0, self.rect.width - 1, self.rect.height - 1
        grid = self.grid
        row, col, tab = key = self.key
        
        # Get borderpens and bgbrushes for rects        
        # Each cell draws its bottom and its right line only
        bottomline = x, y + h, x + w, y + h
        rightline = x + w, y, x + w, y + h
        lines = [bottomline, rightline]
        
        pen_names = ["borderpen_bottom", "borderpen_right"]
        
        borderpens = [get_pen_from_data( \
                        self.table.data_array.get_sgrid_attr(key, pen)) \
                            for pen in pen_names]
        
        # Topmost line if in top cell
        
        if row == 0:
            lines.append((x, y, x + w, y))
            topkey = "top", col, tab
            toppen_data = self.table.data_array.get_sgrid_attr(topkey, 
                                                               pen_names[0])
            borderpens.append(get_pen_from_data(toppen_data))
        
        # Leftmost line if in left cell
        
        if col == 0:
            lines.append((x, y, x, y + h))
            leftkey = row, "left", tab
            toppen_data  = self.table.data_array.get_sgrid_attr(leftkey, 
                                                                pen_names[1])
            borderpens.append(get_pen_from_data(toppen_data))
        
        zoomed_pens = []
        
        for pen in borderpens:
            bordercolor = pen.GetColour()
            borderwidth = pen.GetWidth()
            borderstyle = pen.GetStyle()
            
            zoomed_borderwidth = max(1, 
                int(round(borderwidth * self.grid.grid_renderer.zoom)))
            zoomed_pen = wx.Pen(bordercolor, zoomed_borderwidth, borderstyle)
            zoomed_pen.SetJoin(wx.JOIN_MITER)
            
            zoomed_pens.append(zoomed_pen)
        
        dc.DrawLineList(lines, zoomed_pens)

# end of class Background

